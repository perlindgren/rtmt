module NestedCobs

  use int.Int
  use list.ListRich

  (* cobs <original> <cobs coded> *)
  inductive cobs (list int) (int, list int) =
  | EncodeEnd: cobs Nil (1, Cons 0 Nil) 
  | EncodeZero: forall pl cl: list int, cn:int. cn > 0 -> cobs pl (cn, cl) -> cobs (Cons 0 pl) (1, Cons cn cl)
 (*| DecodeZero: forall pl cl: list int, cn:int. cn > 0 -> pl <> Nil -> cobs (Cons 0 pl) (1, Cons cn cl) -> cobs pl (cn, cl) *)
  | EncodeNonZero: forall l ln: list int, n e:int. n > 0 -> cobs l (n, ln) -> cobs (Cons e l) (1 + n, Cons e ln) 
 (* | NotZero_: forall l ln: list int, n e:int. n > 0 -> cobs (Cons e l) (1 + n, Cons e ln) -> cobs l (n, ln) *)
  
  lemma cobs_end: forall cl. cobs Nil cl -> cl = (1, Cons 0 Nil) 
  lemma cobs_end_nil: forall pl. cobs pl (1, Cons 0 Nil) -> pl = Nil 
  lemma cobs_n_pos: forall pl cn cl. cobs pl (cn, cl) -> cn > 0
  lemma cobs_valid_not_nil: forall pl cn cl. cobs pl (cn, cl) -> cl <> Nil
  lemma cobs_encode_zero: forall pl cn cl. cobs pl (cn, cl) -> cobs (Cons 0 pl) (1, Cons cn cl) 
  lemma cobs_encode_non_zero: forall pnz pl cn cl. cobs pl (cn, cl) -> cobs (Cons pnz pl) (1 + cn, Cons pnz cl) 
  
  predicate is_cobs (n:int) (l: list int) (res: list int) = 
    forall r. cobs r (n, l) -> r = res
  
  let rec function rec_encode (l: list int) : (int, list int)
    variant { l }
    ensures { cobs l result }
    = 
    match l with
    | Nil -> (1, Cons 0 Nil) 
    | Cons e ll -> 
      let (n, ln) = rec_encode ll in
      if e = 0 then 
        (1, Cons n ln) 
      else 
        (1 + n, Cons e ln)  
    end
    
   
    
  (*
  
  lemma cobs_rec_valid: forall pl nc lc. cobs pl (nc, lc) -> 
    match pl with
    | Nil -> (nc, lc) = (1, Cons 0 Nil)
    | Cons plh plt ->  
      match lc with
      | Nil -> false (* absurd *)
      | Cons lch _ -> if plh = 0 then (lch = 1) else true
      end
    end
    
    *)
    (*
      match re = 0 with 
      | True -> 
        n = 1
        (*
        match l with 
        | Nil -> false (*absurd*)
        | Cons le ll -> cobs rl (re, ll)
        
        end
        *)
      | _    -> true
      end
      
    end
    *)
    (*
  (*
    match l with
    | Nil -> true
    | Cons ln ll -> ln > 0
    end
     *)
  
  predicate is_cobs (n:int) (l: list int) (res: list int) = 
    forall r. cobs r (n, l) -> r = res
  
  let rec function rec_encode (l: list int) : (int, list int)
    variant { l }
    ensures { cobs l result }
    = 
    match l with
    | Nil -> (1, Cons 0 Nil) 
    | Cons e ll -> 
      let (n, ln) = rec_encode ll in
      if e = 0 then 
        (1, Cons n ln) 
      else 
        (1 + n, Cons e ln)  
    end
    
  let encode (l: list int) : list int
    ensures { result.length > 0 }
    ensures { 
      match result with
      | Nil -> true
      | Cons n ln -> cobs l (n, ln) 
      end
    }
  = let (n, ll) = rec_encode l in
    Cons n ll  

  let rec function decode (n: int) (l: list int) (ghost r: list int): list int
    requires { cobs r (n, l) }
    variant { l }
    ensures { 
      match result with 
      | Nil -> true (* cannot happen *)
      | lr -> cobs result (n, l) 
      end
    }
  = match l with
    | Nil -> Nil
    | Cons e Nil ->
      assert { e = 0 };
      Nil
      
    | Cons e ll -> 
      assert { n > 0 };
      assert { e <> 0 };
      
      match n = 1 with
      | True -> (* replace zero *)
        match r with
        | Nil -> absurd
        | Cons re rl -> 
        assert { e = re };
        let r = Cons 0 (decode e ll rl) in
        r  
        end
      | False -> 
        match r with
        | Nil -> absurd
        | Cons re rl ->
          let r = Cons e (decode (n - 1) ll rl) in
          r
        end
      end     
    end
  
(*  
  let rec function next_decode (n: int) (l: list int): list int
    requires { n > 0 }
    variant { l }
  = match l with
    | Nil -> Nil
    | Cons e ll -> 
      if e = 0 then
        Nil
      else begin
        if n = 1 then
          (* replace zero *)
          Cons 0 (next_decode e ll)
        else
          Cons e (next_decode (n - 1) ll)
      end     
    end
    
  let rec function next_0 (l: list int) : (int, list int)
    variant { l }
    ensures {
      let (n, _) = result in
      n > 0 
    }
    ensures {
      let (_, ln) = result in
      exists h: list int. h ++ (Cons 0 Nil) = ln
    }
    ensures {
      let (n, ln) = result in
      forall h : list int. h ++ (Cons 0 Nil) = ln -> not (mem 0 h)
    }
    = 
    match l with
    | Nil -> 
      (1, Cons 0 Nil)
    | Cons e ll -> 
      let (n, ln) = next_0 ll in
      assert { n > 0 };
      if e = 0 then
        (1, Cons n ln)
      else begin
        assert { e <> 0 };
        let eln = Cons e ln in 
        assert {
          forall h : list int. h ++ (Cons 0 Nil) = eln -> not (mem 0 h)
        };
        (1 + n, eln)
      end 
    end
    
  let function encode (l: list int) : list int
    ensures { result.length > 0 }
  = let (n, ll) = next_0 l in
    Cons n ll
    
  let rec function decode (l: list int) : list int
    requires {
      forall n t.
        Cons n t = l -> n > 0
    }
    requires { l.length >  0}
    variant { l }
  = match l with
    | Nil -> absurd
    | Cons n ll -> next_decode n ll 
    end 
    
  lemma en_de:
    forall l:list int. 
      decode(encode l) = l
  
  (*
  let rec next_0 (l: list int) : (int, list int)
    variant { l }
    ensures { result = fn_next_0 l }
    ensures { 
    let (_n, ll) = result in 
      ll.length > 0
    
      (* l = Nil -> n = 1 /\
      mem 0 l -> n < l.length /\
      not (mem 0 l) -> ll = l *)
    }
    ensures {
      let (n, ll) = result in 
      fn_decode (Cons n ll) = l   
    }
    = 
    match l with
    | Nil -> (1, Cons 0 Nil)
    | Cons e ll -> 
      let (n, ln) = next_0 ll in

      if e = 0 then
        (1, Cons n ln)
      else 
        (1 + n, Cons e ln)
    end
  
  let encode (l: list int) : list int
    ensures { result.length > 0 }
    ensures { result = fn_encode l }
  = let (n, ll) = next_0 l in
    Cons n ll

  let rec next_decode (l: list int) (n: int): list int
    variant { l } 
    ensures { result = fn_next_decode l n }
    = 
    match l with
    | Nil -> Nil
    | Cons e ll -> 
      if e = 0 then
        Nil
      else begin
        if n = 1 then
          (* replace zero *)
          Cons 0 (next_decode ll e)
        else
          Cons e (next_decode ll (n - 1))
      end     
    end
  
  let decode (l: list int) : list int
    requires { l.length > 0 }
    ensures { result = fn_decode l } 
  = match l with
    | Nil -> absurd
    | Cons n ll -> next_decode ll n
    end 


  let en_de (l: list int) : bool
    ensures { result = true }
  = let e : list int = encode l in
    let d : list int = decode e in
    d.length = l.length

  lemma en_de_length :
    forall l : list int. 
      let e = fn_encode l in
      let d = fn_decode e in
      d.length = l.length
      
  goal en_de_eq :
    forall l : list int. 
      let e = fn_encode l in
      let d = fn_decode e in
      d = l
  *)
  *)
  *)
 
end